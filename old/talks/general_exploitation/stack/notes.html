<html>
 <body>

  <h2>Stack-Based Buffer Overflows</h2>

  <p>
   <h3>Overview</h3>
	A buffer is just a contiguous section of memory.  An overflow 
	overflow obviously refers to writing beyond the memory you are
	supposed to access.  This can be done when a program requesting 
	input from a  user doesn't check the length of the input before
	writing to memory.  It can also happen when a program is expecting
	a certain amount of data (say in a network packet or because of 
   some file format) and the amount of data supplied is greater.
  </p>

  <p>
	<h3>Basic Memory Management</h3>
	Virtual memory is a complicated topic and I'm not going to get into
	anything but the basics.  Its enough to know that every program has
	its own 2<sup>32</sup> bits (about 4GB) of memory to access, however
	it is not allocated contiguously.  Basically, when you are in gdb
	and looking through memory addresses and see a variable at address
	0x0001bd48 and another at 0xfffbe47a, it doesn't mean your program
	is taking up memory from 0x0001bd48 to 0xfffbe47a.
  </p>

  <p>
   <h3>Programs in Memory</h3>
	A programs layout in memory looks something like this
	<br><br>
	<table border=1 cellspacing=0 cellpadding=0>
	 <tr><td>Code</td></tr>
	 <tr><td>Data</td></tr>
	 <tr><td>Heap</td></tr>
	 <tr><td>...</td></tr>
	 <tr><td>&nbsp;<td></tr>
	 <tr><td>...</td></tr>
	 <tr><td>Stack<td></tr>
	</table>
	<br>
	The heap isn't important to us and its enough to know that its where
	memory is allocated dynamically (when the size of the memory is not
	known at compile time).  We are more interested in the stack.
  </p>

  <p>
	<h3>The Stack</h3>
	The stack is where local variables are allocated.  A pointer to this
	section of memory is stored in <b>ebp</b>.  So to allocate a local 
	variable	you subtract the size of the variable from <b>ebp</b>.  The
	stack of a function would look something like this - 
	<br><br>
	<table border=1 cellspacing=0 cellpadding=0>
	 <tr><td>Local Variable<sub>2</sub></td></tr>
	 <tr><td>Local Variable<sub>1</sub></td></tr>
	 <tr><td>Frame Pointer<td></tr>
	 <tr><td>Return Address<td></tr>
	 <tr><td>Paramater<sub>1</sub></td></tr>
	 <tr><td>Paramater<sub>2</sub><td></tr>
	</table>
	<br>
	The return address is the address in memory that the program will
	jump to after the function has finished.  This is the key part of 
	a stack overflow.
	Also, notice that paramater<sub>2</sub> is passed before 
	paramater<sub>1</sub> (assuming something like function(p1, p2)).  
	This is the standard for C functions.  There are other calling 
	conventions (pascall, fastcall) that don't pass paramaters the same
	way.  
  </p>

  <p>
	<h3>Executing Code</h3>
	The most common way to exploit a stack overflow is to try to execute
	some prepared code (shell, reverse shell, adding a user, etc).  The
	basic idea that you write past the buffer into the return address.
	You then set the return address to an area in memory that you have
	placed code.  This can either be in the buffer or after it.  When
	storing your code in the buffer you have a few issues to worry about.
	Your code must fit in the buffer so you are size limited.  You also
	have to be sure your code doesn't contain zeros which would 
	effectivly null terminate the string.  When you store your code past
	the buffer (after the overwritten return address) you don't have to
	worry about those things.  You do have to worry about overwriting
	aribitrary data which might crash the program (and then your code
	wouldn't execute).  Because of this, the first method is more 
	common.  An example of an exploitable program can be found 
	<a href="code_execution.c">here</a> with a perl script to exploit it
	<a href="exploit.pl">here</a>.
  </p>

  <p>
   <h3>Corrupting Variables</h3>
	You may notice that when we overwrite the return address,  we also
	overwrite everything up to that point.  This includes any local
	variables declared before the buffer.  Another type of exploit 
	involves overflowing the buffer with data that affects local 
	variables.  See an example <a href="variable_corruption.c">here</a>.
  </p>

 </body>
</html>
