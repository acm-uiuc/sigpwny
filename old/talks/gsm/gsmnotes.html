<HTML><HEAD><TITLE>Notes on GSM</TITLE></HEAD><BODY><center><h1>Notes on GSM</h1></center><center><b>By: Chris Grier &lt;grier@uiuc.edu&gt;</b></center><br><h2>1. Network Overview</h2><blockquote>From a customer perpective, there are really only 2parts to the GSM network, a cell phone and the "other end". The GSMstandard defines much more than that. The high level description ofthe network is as follows, starting from your end.<ol>  <li>Mobile Station - Your phone. It's a wireless telephone and adata terminal which can send and recieve messages from the network.  <li>Base Transceiver Station (BTS) - the stuff that interfacesdirectly with your phone. This consists of fixed locationtransmitters and recievers for the cell which it is in charge of.Different radio types are used for different things, such assubscriber-to-network and network-to-subscriber, different datatypes, and signaling. This is "the tower" in your backyard.  <li>Base Station Controller (BSC) - handles 1 or more BTS.Gateways to the network.  <li>Mobile Switching Centers (MSC) connect the GSM network to thepublic switched telephone networks. Also provide a way to access thedatabases for who's where and who can do what.  <li>Home Locator Register (HLR) and Authentication Center (AUC) -the databases. These things have stuff for users on the network,guests/visitors on the network, subscriber information -particularly profile. Permananent user info is in the KLR, and theVLR stores temporary info about a mobile phone.  <li>PSTN/ISDN - The switched network backbones.</ol></blockquote><h2>2. Signals and RF Stuff</h2><h3>2.1 Overview</h3><blockquote>GSM uses Frequency Division Multiplexing AND TimeDivision Multiplexing. FDMA divides the frequency ranges for GSM,which are 890-915, 935-960 and some others that the book didn'thave. Each is divided into 200kHz wide channels. As far as TDMAgoes, each time slot is 577 micro seconds long, 8 time slices is aframe, lasting for a grand total of 4.615ms. A multiframe consistsof 51 frames, 51 multiframes make up a Superframe, and 2048Superframes make a Hyperframe which is 2715648 frames.Wow.</blockquote><h3>2.2 RF Specifics (stolen right from the book)</h3><blockquote>  <table>    <tr><td>Parameter</td><td>Value</td></tr> <tr><td>Downstream Frequencies</td><td>935-960MHz, 1805-1880MHz</td></tr> <tr><td>Upstream Frequency</td><td>890-915MHz, 1710-1785MHz</td></tr> <tr><td>Channel Spacing</td><td>200kHz</td></tr> <tr><td>Duplex Spacing</td><td>45MHz</td></tr> <tr><td>Radio Power</td><td>13-39dBm, 2dB steps</td></tr> <tr><td>Data Rise/Fall Time</td><td>28 microseconds</td></tr> <tr><td>Emissions</td><td>&lt; -36dBm</td></tr> <tr><td>Phase Error</td><td>5 deg RMS</td></tr> <tr><td>Freq Error</td><td>95Hz</td></tr> <tr><td>Recv Sensitivity</td><td>104dBm</td></tr> <tr><td>Co-channel Rejection</td><td>96dBm below signal</td></tr> <tr><td>Intermodulation Rejection</td><td>100dBm below signal</td></tr> <tr><td>Signal Blocking Level</td><td>100dBm</td></tr> </table></blockquote>  <h3>2.3 Packets and data</h3><blockquote>   <p>During a single time slot is your phone transmitting, and the contents of     the time slot is called a packet. Packets are made of bits, and bits are made     of magic.</p></blockquote><blockquote>A packet can be 4 different things:   <ul>    <li>random access burst - shorter than the normal burst.    <li>synchronization burst - same length as the normal burst but a different       structure    <li>normal burst - carries speech or data information. lasts approximately       0.577 ms and has a length of 156.25 bits    <li>frequency correction burst - same length as the normal burst but a different       structure  </ul>  Each type has a different packet structure, and is visible here:<br>  <img src="ttch.gif" width="486" height="296"> <br>  If you're interested in channel specifics, look at <a href="http://www.comms.eee.strath.ac.uk/%7Egozalvez/gsm/gsm.html#5.2">http://www.comms.eee.strath.ac.uk/~gozalvez/gsm/gsm.html#5.2</a></blockquote><h2>3. The Network Subsystem</h2><blockquote>The main component here is the MSC. The MSC contains the HomeLocator Register (HLR), Visitor Locator Register (VLR), andAuthentication Center (AUC). These are the most interesting non-RFrelated parts of the system back end.</blockquote><h3>3.1 HLR</h3><blockquote>The HLR contains a lot of interesting information. TheHLR is responsible for subscription details, and supplementaryservices. It also maintains information on the last know locationand status of a particular phone.</blockquote><blockquote>Since a user can use any phone with his or her SIM card,there's a protocol necessary to manage accessing the network.Information contained on the SIM card is transmitted to the HLR toverify the identity of the subscriber. Location and status arecontinually updated in the HLR based on the base station reports andcell phone status. Any messages to be sent to the subscriber arequeued in the HLR. All call setup queries ask the HLR forinformation before doing anything else.</blockquote> <h3>3.2 VLR</h3><blockquote>Like the HLR, the VLR keeps track of users but onlywithin the area thet the VLR is assigned. The VLR communicates withthe HLR to figure out where to route calls, and to keep track ofpeple as they move around.</blockquote><h3>3.3 AUC</h3><blockquote>The AUC is basically just a database full onfconfidential subscriber information attached to the back of the HLR.Its located in a "secure place" and the data is stored in "coded"form (sounds like encryption to me).  The AUC is responsible forcontrolling the rights of usage of the network services, i.e. phonecalls, data, internet, etc... The AUC allows the Network Operator(Cingular, AT&amp;T) to know "unambiguiusly" who is on the networkfor billing purposes. The AUC also protects the user from fraud(somehow ...) and contains the secret information necessary tohandle authentication and encryption.</blockquote><h4>3.3.1 Authentication with the network</h4><blockquote>Authentication on the network works as follows. Firstthe mobile terminal is asked to perform a computation on a randomnumber supplied by the system using a secret key stored on the SIMcard. The system does this calculation internally, and compares theoutputs. Both the algorithm and key are stored in secureformats.</blockquote><blockquote>More detailed authentication ... When a terminalconnects to the network, a RNG gives it a number N which isencrypted with a secret personal key Kp. The resulting number isencrypted with an algorithm called A3 and transmitted back to thenetwork and compared. The subscriber then generates a session keyfor encrpytion using the algorithm A8. The encryption algorithm A5is used to encrypt each packet.</blockquote><blockquote>After the subscriber is verified, the encryption ofradio packets is handled by a different algorithm, called A5 (A3 isused during subscriber verification). The encryption key is suppliedduring authentication, using some key agreement scheme and eachpacket is also encrypted using a changing IV of some variety, whichappears to be a packet number. I do not think either of thesealgorithms are officially public (LINKS?).</blockquote> <h4>3.3.2 Encryption and Security</h4><blockquote>There are 3 main algorithms used in GSM. Each of thesealgorithms is a trade secret and only released to people who the GSMcommittee determines has a need-to-know.</blockquote><blockquote><table><tr><td>Name</td><td>Use</td><td>Basics</td></tr><tr><td>A3</td><td>Authentication</td><td>None</td></tr><tr><td>A5</td><td>Encryption/Decryption Algorithm for packetencryption</td><td>3 Sparsely loopedback LFSRs in the originalversion, lots of variants</td></tr><tr><td>A8</td><td>Cipher Key Generator</td><td>Basically a one wayfunction</td></tr></table></blockquote><blockquote>A5 is a stream algorithm and is reset for each packet with the orignal   key plus some key frame number. Ross Anderson in [1] suggests that A5/1 has   about an equivalent key strength of about 40 bits. Code? No?   <pre>typedef struct {<br>        unsigned long rl,r2,r3;<br>} a5 ctx;<br>static int threshold(rl, r2, r3)<br>unsigned int rl;<br>unsigned int r2.<br>unsigned int r<br>{<br>int total;<br>  total = (((r1 &gt;&gt;  9) &amp; 0x1) == 1) +<br>          (((r2 &gt;&gt; 11) &amp; 0x1) == 1) +<br>          (((r3 &gt;&gt; 11) &amp; 0x1) == 1);<br>  if (total &gt; 1)<br>    return (0);<br>  else<br>    return (1):<br>}<br>unsigned long clock_r1(ctl, r1)<br>int ctl<br>unsigned lonq r1:<br>{<br>unsigned long feedback;<br>  ctl ^= ((rl &gt;&gt; 9) &amp; Oxl);<br>  if (ctl)<br>  {<br>    feedback = (r1 &gt;&gt; 18) ^ (r1 &gt;&gt; 17) ^ (r1 &gt;&gt; 16) ^ (r1 &gt;&gt; 13);<br>    r1 = (r1 &lt;&lt; 1) &amp; Ox7ffff;<br>    if (feedback &amp; 0x01)<br>    r1 ^= 0x01:<br>  }<br>    return (r1);<br>}<br>unsigned long clock_r2(ctl, r2)<br>int ctl;<br>unsigned long r2;<br>{<br>unsigned long feedback;<br>  ctl ^= ((r2 &gt;&gt; 11) &amp; 0x1);<br>  if (ctl)<br>  {<br>    feedback = (r2 &gt;&gt; 21) ^ (r2 &gt;&gt; 20) ^ (r2 &gt;&gt; 16) ^ (r2 &gt;&gt; 12);<br>    r2 = (r2 &lt;&lt; 1) &amp; 0x3fffff;<br>    if (feedback &amp; 0x01)<br>    r2 ^= 0x01;<br>  }<br>    return (r2):<br>}<br>unsigned long clock_r3(ctl, r3)<br>int ctl<br>unsigned long r3;<br>{<br>unsigned long feedback;<br>  ctl ^= ((r3 &gt;&gt; 11) &amp; 0x1,<br>  if (ctl)<br>  {<br>    feedback = (r3 &gt;&gt; 22) ^ (r3 &gt;&gt; 21) ^ (r3 &gt;&gt; 18) ^ (r3 &gt;&gt; 17);<br>    r3 = (r3 &lt;&lt; 1) &amp; 0x7fffff;<br>    if (feedback &amp; 0x01)<br>    r3 ^= 0x01:<br>  }<br>  return (r3);<br>}<br>  int keystream(key, frame, alice, bob)<br>  unsigned char *key;   /* 64 bit session key              */<br>  unsigned long frame;  /* 22 bit frame sequence number    */<br>  unsigned char *alice; /* 114 bit Alice to Bob key stream */<br>  unsigned char *bob;   /* 114 bit Bob to Alice key stream */<br>  {<br>  unsigned long rl;   /* 19 bit shift register */<br>  unsigned long r2;   /* 22 bit shift register */<br>  unsigned long r3;   /* 23 bit shift register */<br>  int i;              /* counter for loops     */<br>  int clock_ctl;      /* xored with clock enable on each shift register<br>  unsigned char *ptr; /* current position in keystream */<br>  unsigned char byte; /* byte of keystream being assembled */<br>  unsigned int bits;  /* number of bits of keystream in byte */<br>  unsigned int bit;   /* bit output from keystream generator */<br>    /* Initialise shift registers from session key */<br>    r1 = (key[0] I (key[1] &lt;&lt; 8) 1 (key[2] &lt;&lt; 16) ) &amp; 0x7ffff;<br>    r2 = ((key[2] &gt;&gt; 3) 1 (key[3] &lt;&lt; 5) 1 (key[4] &lt;&lt; 13) 1 (key[5] &lt;&lt; 21)) &amp;<br>  0x3fffff;<br>    r3 = ((key[5] &gt;&gt; 1) 1 (key[6] &lt;&lt; 7) 1 (key[7] &lt;&lt; 15) ) &amp; 0x7fffff;<br>    /* Merge frame sequence number into shift register state, by xor'ing it<br>     * into the feedback path<br>     */<br>    for (i=0;i&lt;22;i++)<br>    {<br>      clock_ctl = threshold(r1, r2, r2);<br>      r1 = clock r1(clock_ctl, r1);<br>      r2 = clock_r2(clock_ctl, r2);<br>      r3 = clock_r3(clock_ctl, r3);<br>      if (frame &amp; 1)<br>      {<br>      r1 ^= 1;<br>      r2 ^= 1;<br>      r3 ^= 1;<br>      frame = frame &gt;&gt; 1;<br>    }<br>    /* Run shift registers for 100 clock ticks to allow frame number to<br>     * be diffused into all the bits of the shift registers<br>     */<br>   for (i=0;i&lt;100;i++)<br>   {<br>     clock_ctl = threshold(r1, r2, r2);<br>     r1 = clock r1(clock_ctl, r1);<br>     r2 = clock_r2(clock ctl, r2);<br>     r3 = clock r3(clock_ctl, r3);<br>   }<br>   /* Produce 114 bits of Alice-&gt;Bob key stream */<br>   ptr = alice;<br>   bits = 0;<br>   byte = 0;<br>   for (i=0;i&lt;114;i++)<br>   {<br>     clock_ctl = threshold(r1, r2, r2);<br>     r1 = clock rl(clock_ctl, r1);<br>     r2 = clock_r2(clock ctl, r2);<br>     r3 = clock_r3(clock_ctl, r3);<br>     bit = ((rl &gt;&gt; 18) ^ (r2 &gt;&gt; 21) ^ (r3 &gt;&gt; 22)) &amp; 0x01;<br>     byte = (byte &lt;&lt; 1) | bit;<br>     bits++;<br>     if (bits == 8)<br>     {<br>       *ptr = byte;<br>       ptr++;<br>       bits = 0;<br>       byte = 0;<br>     }<br>}<br>if (bits)<br>  *ptr = byte;<br>/* Run shift registers for another 100 bits to hide relationship between<br> * Alice-&gt;Bob key stream and Bob-&gt;Alice key stream.<br>for (i=0;i&lt;100;i++)<br>{<br>  clock_ctl = threshold(r1, r2, r2);<br>  r1 = clock_r1(clock_ctl, r1);<br>  r2 = clock r2(clock_ctl, r2);<br>  r3 = clock r3(clock ctl, r3);<br>}<br>/* Produce 114 bits of Bob-&gt;Alice key stream<br>ptr = bob;<br>bits = 0:<br>byte = 0;<br>for (i=U;i&lt;114;i++)<br>{<br>  clock_ctl = threshold(r1, r2, r2);<br>  r1 = clock r1(clock_ctl, r1);<br>  r2 = clock_r2(clock ctl, r2);<br>  r3 = clock_r3(clock ctl, r3);<br>  bit = ((r1 &gt;&gt; 18) ^ (r2 &gt;&gt; 21) ^ (r3 &gt;&gt; 22)) &amp; 0x01;<br>  byte = (byte &lt;&lt; 1) | bit;<br>  bits++;<br>  if (bits == 8)<br>  {<br>    *ptr = byte;<br>    ptr++<br>    bits = 0;<br>    byte = 0;<br>  }<br>}<br>  if (bits)<br>    *ptr = byte;<br>  return (0);<br>}<br>void a5_key(a5_ctx *c, char *k)(<br>        c-&gt;rl = k[0]&lt;&lt;11|k[1]&lt;&lt;3 | k[2]&gt;&gt;5          ; /* 19 */<br>        c-&gt;r2 = k[2]&lt;&lt;17|k[3]&lt;&lt;9 | k[4]&lt;&lt;1 I k[5]&gt;&gt;7; /* 22 */<br>        c-&gt;r3 = k[5]&lt;&lt;15|k[6]&lt;&lt;8 | k[7]             ; /* 23 */<br>}<br>/* Step one bit in A5, return 0 or 1 as output bit. */<br>int a5_step(a5 ctx *c){<br>        int control;<br>        control = threshold(c-&gt;r1,c-&gt;r2,c-&gt;r3);<br>        c-&gt;r1 = clock_r1(control,c-&gt;r1);<br>        c-&gt;r2 = clock_r2(control,c-&gt;r2);<br>        c-&gt;r3 = clock_r3(control,c-&gt;r3);<br>        return( (c-&gt;r1^c &gt;r2^c-&gt;r3)&amp;1);<br>}<br>/* Encrypts a buffer of len bytes. */<br>void a5_encrypt(a5_ctx *c, char *data, int len)l<br>        int i,j;<br>        char t;<br>        for(i=0:i&lt;len i++)<br>                for(j=0;j&lt;8;j++) t = t&lt;&lt;1 | a5_step(c)<br>                data[i]^=t;<br>        }<br>}<br>void a5_decrypt(a5_ctx *c, char *data, int len){<br>        a5_encrypt(c,data,len);<br>}<br>void main(void){<br>        a5_ctx c;<br>        char data[100];<br>        char key[] = {1,2,3,4,5,6,7,8};<br>        int i,flag;<br>        for(i=0;i&lt;100;i++) data[i] = i;<br>        a5_key(&amp;c,key);<br>        a5_encrypt(&amp;c,data,100);<br>        a5_key(&amp;c,key);<br>        a5_decrypt(&amp;c,data,1);<br>        a5_decrypt(&amp;c,data+1,99);<br>        flag = 0;<br>        for(i=0;i&lt;100;i++) if(data[i]!=i)flag = 1;<br>        if(flag)printf(&quot;Decrypt failed\n&quot;); else printf(&quot;Decrypt succeeded\n&quot;);<br>}</pre>  I haven't had time to look at this code yet, but it looks interesting ... maybe   its A5? Who knows. Keep going.</blockquote><blockquote>A3 is another algorithm which is "secret" algorithmcalled COMP128 for this and A8. COMP128 takes a key and a randomnumber and produces the answer to verify the subscriber duringauthentication as well as the key to start encrypting the packetswith. At the same time! What a deal! The signed response is 32 bits,and the encryption key is 54 (64 with the last 10 bits =0).</blockquote><h3>3.4 Unique User Identification</h3><blockquote>Each mobile radio has a couple security features tokeept it from being stolen. Each phone is built with a InternationalMobile Equipment Identity (IMEI), and this is done in the factorybeofore the phone is even activated. Each time the mobile radio isused, the network checks the IMEI against some list of authorizedand banned numbers to verify that the phone is allowed to be on thenetwork. </blockquote><blockquote></blockquote><h3>Bibliography</h3><blockquote><p>1. The Internet  <ul>    <li>http://www.dia.unisa.it/professori/ads/corso-security/www/CORSO-9900/a5/Netsec/netsec.html     <li>http://jya.com/crack-a5.htm     <li>http://www.comms.eee.strath.ac.uk/~gozalvez/gsm/gsm.html  </ul><p>2. Stuckmann P., <i>The GSM Evolution: Mobile Packet DataServices</i>, West Sussex: John Wiley &amp; Sons, Ltd., 2003.<p>4. Steele, R., Lee, C., and Gould, P., <i>GSM, cdmaOne and 3GSystems</i> West Sussex: John Wiley &amp; Sons, Ltd., 2001.<p>3. Tisal, J., <i>The GSM Network GPRS Evolution: One StepTowards UMTS</i>, West Sussex: John Wiley &amp; Sons, Ltd., 2001.</blockquote><blockquote></blockquote></body></html>